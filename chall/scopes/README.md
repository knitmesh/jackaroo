## 考察作用域与变量声明的小题一道
先来看一下题目：   

```
f = function() {
  return true;
};
g = function() {
  return false;
};
(function() {
  if (g() && [] == ![]) {
    f = function f() {
      return false;
    };
  }
  function g() {
    return true;
  }
})();
f() // true or false ?
```

思考一下，再到浏览器的console里试一试，看看和你的结果是否一致   

### 走起来！

先说一下，最后f()运行的结果是false

我们将代码捋一遍，看看引擎在运行这段代码的时候做了哪些事情  

---
首先，在最开始定义了两个变量```f```与```g```

```
f = function() {
  return true;
};
g = function() {
  return false;
};
```  

接着是一个立即执行函数
```
(function() {
  if (g() && [] == ![]) {
    f = function f() {
      return false;
    };
  }
  function g() {
    return true;
  }
})();

```
注意，这里坑就来了！！

来看这个立即执行函数里的```if```语句
```
if (g() && [] == ![]) {
//...
}
```
稍有常识的人都可以看出，这个螳臂当车的```g()```，**并不是我们在前面声明的那个函数表达式**

在```if()```语句的下面，紧接着声明了一个函数```g```
```
function g() {
  return true;
}
```
**引擎在编译这段立即执行函数时，会将这个函数声明“提前”**   

形如这样
```
(function() {
  function g() {
    return true;
  }
  if (g() && [] == ![]) {
    f = function f() {
      return false;
    };
  }
})();
```
也就是说```if```中的那个```g()```实际上结果是true

那么```g()```后面的那个```[] == ![]```呢？

它的结果也是true（在考察作用域的题目里突然出现了考察类型转换也是有点乱入...）

#### 这里涉及到了```==```与```!```运算时的类型转换

首先，```!```的运算优先级是大于```==```的

这里先进行了```![]```的操作

```!``` 操作符会将数据类型转换为bool后进行取反，而js中对bool的类型转换规则是**真值为true，假值为false**

那么，什么是真值，什么是假值呢？   

js中的假值就那么几种:   

```
undefined
null
false
+0
-0
NAN
''//空字符串
```
除了以上所列的假值，**其余都为真值**

因此，```![]```的结果为false

```[] == ![]``` 就变成了 ```[] == false```  

对于```==```中bool值与其他类型比较时，**bool值类型会先```ToNumber()```**   

```false``` ToNumber的结果是```0```，现在就成了```[] == 0```的判断   

再来看对象的判断规则

对于```==```操作符中object与其他类型比较时，**object会先```ToPrimitive()```**

本例中```[]``` ToPrimitive的结果是 ```''``` （一个空字符串）

于是现在判断逻辑为```'' == 0```

最后，对于```==```中字符串与其他类型的比较，**字符串会先```ToNumber()```**   

```''```ToNumber的结果是```0```  

```0 == 0```，结果就是true咯~

回过头来看这段立即执行函数
```
(function() {
  if (g() && [] == ![]) {
    f = function f() {
      return false;
    };
  }
  function g() {
    return true;
  }
})();

```
```if``` 表达式中重新定义了变量 ```f```
```
f = function f() {
return false;
};
```
其取代了最开始对之前对 ```f``` 的定义

最后的```f()```结果便是false啦~
