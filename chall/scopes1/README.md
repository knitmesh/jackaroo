## 考察作用域与函数参数的小题一道
这道题除了考察了变量声明外，还捎带考察了一下函数参数引用，来看看：   

```
var foo = {
  n: 1
};

(function(foo) {
  console.log(foo.n);
  foo.n = 3;

  var foo = {
    n: 2
  };

  console.log(foo.n);
})(foo);

console.log(foo.n)
```   

注意立即执行函数中的那个```foo```的声明，一定要看仔细了哈~   

### 走起来！   

先说一下答案：   

```
1
2
3
```  

直接看这段立即执行函数   

首先要知道，它在经过引擎编译后会变成这个样子：

```
(function(foo) {
  var foo = foo;
  //...
})(foo);
```

立即执行函数中虽然有对```foo```重新声明，但这里编译后的声明其实和原本的声明关系不大   

这是引擎对函数参数的一种“普遍处理”。如果将立即执行函数中的```var```关键字去掉，也可以看到运行的结果和原来是一样的   

不过这不是关键，这道题里相对考察的重点是函数参数对对象类型的处理   

**对于对象类型的函数参数，参数传递的是对对象的引用**，可以理解为其他语言的“引用传值”   

对于这个立即执行函数   

```
(function(foo) {
  var foo = foo;

  console.log(foo.n);
  foo.n = 3;

  foo = {
    n: 2
  };

  console.log(foo.n);
})(foo);
```
第一个```console.log()```打印的就是最开始定义的```foo```，其值为```1```   

然后对```foo```的```n```进行了赋值   

```
foo.n = 3;
```

这里就是坑的所在了！   

由于对象类型的参数是对象的引用，对```foo```中```n```的赋值是直接影响外层最开始定义的```foo```的！   

之后把```foo```赋值为一个新的对象   

此时立即执行函数内定义的```foo```和外部脱离关系，随后打印的结果```n```也是新赋值对象中```n```的值```2```   

要注意的是虽然立即执行函数内部的```foo```被重新赋值，但外部的```foo```不会受到影响，可以理解为**重新被赋值的```foo```只是修改了引用，指向了一个新的对象**   

立即执行函数结束，最后的一个```console.log```打印结果为```3```   

---

虽然还是一道考察作用域的题目，但对于函数参数相关的东西很多人还是栽了进去吧~~   

还是希望大家能够从这道题目出发，拓宽眼光与思路，举一反三
