## 考察原型链的一道小题
今天的这道小题简单的考察了一下大家对原型链的理解，来看看题目：

```
var A = {
  n: 1
}
var B = function() {
  this.n = 9999
};
var C = function() {
  var n = 8888
};

B.prototype = A;
C.prototype = A;

var b = new B();
var c = new C();

A.n++;

console.log(b.n);
console.log(c.n);
```   

要注意```C```定义中的那个```n```的声明哈~   

### 走起来！

先说一下答案   

```
9999
2
```   

基本上没有什么难度，哈哈   

直接来看代码   

```
var B = function() {
  this.n = 9999
};
var C = function() {
  var n = 8888
};

B.prototype = A;
C.prototype = A;
```   

```B```和```C```在声明之后，其原型链指向了A，此时```B```和```C```的实例在使用```this.n```时会通过原型链查找到```A```   

但注意```B```和```C```内部的东西   

在使用```new```关键字对```B```和```C```进行实例化的时候，会执行```B```与```C```   

看看接下来的代码    

```
var b = new B();
var c = new C();
```   

在实例化```b```的时候执行了```this.n = 9999```的操作，要注意这里的```n```并不是原型链上```A```的那个```n```。这个操作仅仅是在原型链上```b```的这一层声明了一个```n```并赋值为```9999```，原型链上```A```的那个```n```依然是```1```，不会受到影响   

在实例化```c```的时候执行了```var n = 8888```的操作，它声明了一个```n```，跟原型链没有任何关系。```n```在实例化函数运行完也会随着垃圾回收被处理掉   

```
console.log(b.n);
console.log(c.n);
```

访问```b```的```n```，原型链上```b```就有```n```，直接读取结果```9999```   

访问```c```的```n```，会随着原型链向上查询，最后读取```A```的```n```。```A```的```n```进行了自加操作，其结果是```2```   

---

这道小题真的很简单，考察点除了原型链外，关键字```new```的执行过程也要有所了解

